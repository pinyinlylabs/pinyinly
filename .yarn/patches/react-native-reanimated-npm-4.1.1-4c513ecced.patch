diff --git a/lib/module/createAnimatedComponent/AnimatedComponent.js b/lib/module/createAnimatedComponent/AnimatedComponent.js
index ddf04213bddd9502e8961448f55ca877789ea067..375a693468563f4e2185c42e4affc0627f74fee8 100644
--- a/lib/module/createAnimatedComponent/AnimatedComponent.js
+++ b/lib/module/createAnimatedComponent/AnimatedComponent.js
@@ -65,6 +65,16 @@ export default class AnimatedComponent extends ReanimatedAnimatedComponent {
     }
     this._configureLayoutAnimation(LayoutAnimationType.LAYOUT, this.props.layout);
     this._configureLayoutAnimation(LayoutAnimationType.EXITING, this.props.exiting);
+    {
+      // In the case where the component was unmounted and had an exit animation,
+      // move back the elements that were moved into the dummy element.
+      const dummyRef = this._componentDOMRef.reanimatedDummyRef;
+      dummyRef?.getAnimations().forEach(x => x.cancel());
+      while (dummyRef?.firstChild) {
+        this._componentDOMRef.appendChild(dummyRef.firstChild);
+      }
+      this._componentDOMRef.reanimatedDummyRef = null;
+    }
     if (IS_WEB) {
       if (this.props.exiting && this._componentDOMRef) {
         saveSnapshot(this._componentDOMRef);
diff --git a/lib/module/createAnimatedComponent/AnimatedComponent.js.orig b/lib/module/createAnimatedComponent/AnimatedComponent.js.orig
new file mode 100644
index 0000000000000000000000000000000000000000..ddf04213bddd9502e8961448f55ca877789ea067
--- /dev/null
+++ b/lib/module/createAnimatedComponent/AnimatedComponent.js.orig
@@ -0,0 +1,273 @@
+'use strict';
+
+import '../layoutReanimation/animationsManager';
+import { maybeBuild } from '../animationBuilder';
+import { IS_JEST, IS_WEB, logger } from '../common';
+import { LayoutAnimationType } from '../commonTypes';
+import { SkipEnteringContext } from '../component/LayoutAnimationConfig';
+import ReanimatedAnimatedComponent from '../css/component/AnimatedComponent';
+import { configureWebLayoutAnimations, getReducedMotionFromConfig, saveSnapshot, startWebLayoutAnimation, tryActivateLayoutTransition } from '../layoutReanimation/web';
+import { addHTMLMutationObserver } from '../layoutReanimation/web/domUtils';
+import { updateLayoutAnimations } from '../UpdateLayoutAnimations';
+import { InlinePropManager } from './InlinePropManager';
+import jsPropsUpdater from './JSPropsUpdater';
+import { NativeEventsManager } from './NativeEventsManager';
+import { PropsFilter } from './PropsFilter';
+import { filterStyles, flattenArray } from './utils';
+let id = 0;
+if (IS_WEB) {
+  configureWebLayoutAnimations();
+}
+export default class AnimatedComponent extends ReanimatedAnimatedComponent {
+  _animatedStyles = [];
+  _prevAnimatedStyles = [];
+  _animatedProps = [];
+  _prevAnimatedProps = [];
+  _isFirstRender = true;
+  jestAnimatedStyle = {
+    value: {}
+  };
+  jestAnimatedProps = {
+    value: {}
+  };
+  _InlinePropManager = new InlinePropManager();
+  _PropsFilter = new PropsFilter();
+  static contextType = SkipEnteringContext;
+  reanimatedID = id++;
+  constructor(ChildComponent, props, displayName, options) {
+    super(ChildComponent, props);
+    this._options = options;
+    this._displayName = displayName;
+    if (IS_JEST) {
+      this.jestAnimatedStyle = {
+        value: {}
+      };
+      this.jestAnimatedProps = {
+        value: {}
+      };
+    }
+    const skipEntering = this.context?.current;
+    if (!skipEntering) {
+      this._configureLayoutAnimation(LayoutAnimationType.ENTERING, this.props.entering);
+    }
+  }
+  componentDidMount() {
+    super.componentDidMount();
+    if (!IS_WEB) {
+      // It exists only on native platforms. We initialize it here because the ref to the animated component is available only post-mount
+      this._NativeEventsManager = new NativeEventsManager(this, this._options);
+    }
+    this._NativeEventsManager?.attachEvents();
+    this._updateAnimatedStylesAndProps();
+    this._InlinePropManager.attachInlineProps(this, this._getViewInfo());
+    if (this._options?.jsProps?.length) {
+      jsPropsUpdater.registerComponent(this, this._options.jsProps);
+    }
+    this._configureLayoutAnimation(LayoutAnimationType.LAYOUT, this.props.layout);
+    this._configureLayoutAnimation(LayoutAnimationType.EXITING, this.props.exiting);
+    if (IS_WEB) {
+      if (this.props.exiting && this._componentDOMRef) {
+        saveSnapshot(this._componentDOMRef);
+      }
+      if (!this.props.entering || getReducedMotionFromConfig(this.props.entering)) {
+        this._isFirstRender = false;
+        return;
+      }
+      const skipEntering = this.context?.current;
+      if (!skipEntering) {
+        startWebLayoutAnimation(this.props, this._componentDOMRef, LayoutAnimationType.ENTERING);
+      } else if (this._componentDOMRef) {
+        this._componentDOMRef.style.visibility = 'initial';
+      }
+    }
+    this._isFirstRender = false;
+  }
+  componentWillUnmount() {
+    super.componentWillUnmount();
+    this._NativeEventsManager?.detachEvents();
+    this._detachStyles();
+    this._InlinePropManager.detachInlineProps();
+    if (this._options?.jsProps?.length) {
+      jsPropsUpdater.unregisterComponent(this);
+    }
+    const exiting = this.props.exiting;
+    if (IS_WEB && this._componentDOMRef && exiting && !getReducedMotionFromConfig(exiting)) {
+      addHTMLMutationObserver();
+      startWebLayoutAnimation(this.props, this._componentDOMRef, LayoutAnimationType.EXITING);
+    }
+  }
+  _detachStyles() {
+    const viewTag = this.getComponentViewTag();
+    if (viewTag !== -1) {
+      for (const style of this._animatedStyles) {
+        style.viewDescriptors.remove(viewTag);
+      }
+      if (this.props.animatedProps?.viewDescriptors) {
+        this.props.animatedProps.viewDescriptors.remove(viewTag);
+      }
+    }
+  }
+  setNativeProps(props) {
+    if (this._options?.setNativeProps) {
+      this._options.setNativeProps(this._componentRef, props);
+    } else {
+      this._componentRef?.setNativeProps?.(props);
+    }
+  }
+  _handleAnimatedStylesUpdate(prevStyles, currentStyles, jestAnimatedStyleOrProps) {
+    const {
+      viewTag,
+      shadowNodeWrapper
+    } = this._getViewInfo();
+    const newStyles = new Set(currentStyles);
+
+    // remove old styles
+    if (prevStyles) {
+      // in most of the cases, views have only a single animated style and it remains unchanged
+      const hasOneSameStyle = currentStyles.length === 1 && prevStyles.length === 1 && currentStyles[0] === prevStyles[0];
+      if (hasOneSameStyle) {
+        return;
+      }
+
+      // otherwise, remove each style that is not present in new styles
+      for (const prevStyle of prevStyles) {
+        const isPresent = currentStyles.some(style => {
+          if (style === prevStyle) {
+            newStyles.delete(style);
+            return true;
+          }
+          return false;
+        });
+        if (!isPresent) {
+          prevStyle.viewDescriptors.remove(viewTag);
+        }
+      }
+    }
+    newStyles.forEach(style => {
+      style.viewDescriptors.add({
+        tag: viewTag,
+        shadowNodeWrapper
+      }, style.styleUpdaterContainer);
+      if (IS_JEST) {
+        /**
+         * We need to connect Jest's TestObject instance whose contains just
+         * props object with the updateProps() function where we update the
+         * properties of the component. We can't update props object directly
+         * because TestObject contains a copy of props - look at render
+         * function: const props = this._filterNonAnimatedProps(this.props);
+         */
+        Object.assign(jestAnimatedStyleOrProps.value, style.initial.value);
+        style.jestAnimatedValues.current = jestAnimatedStyleOrProps;
+      }
+    });
+  }
+  _updateAnimatedStylesAndProps() {
+    this._handleAnimatedStylesUpdate(this._prevAnimatedStyles, this._animatedStyles, this.jestAnimatedStyle);
+    this._handleAnimatedStylesUpdate(this._prevAnimatedProps, this._animatedProps, this.jestAnimatedProps);
+  }
+  componentDidUpdate(prevProps, _prevState, snapshot) {
+    this._configureLayoutAnimation(LayoutAnimationType.LAYOUT, this.props.layout, prevProps.layout);
+    this._configureLayoutAnimation(LayoutAnimationType.EXITING, this.props.exiting, prevProps.exiting);
+    this._NativeEventsManager?.updateEvents(prevProps);
+    this._updateAnimatedStylesAndProps();
+    this._InlinePropManager.attachInlineProps(this, this._getViewInfo());
+    if (IS_WEB && this.props.exiting && this._componentDOMRef) {
+      saveSnapshot(this._componentDOMRef);
+    }
+    if (IS_WEB && snapshot && this.props.layout && !getReducedMotionFromConfig(this.props.layout)) {
+      tryActivateLayoutTransition(this.props, this._componentDOMRef, snapshot);
+    }
+  }
+  _updateStyles(props) {
+    const filteredStyles = filterStyles(flattenArray(props.style ?? []));
+    this._prevAnimatedStyles = this._animatedStyles;
+    this._animatedStyles = filteredStyles.animatedStyles;
+    const filteredAnimatedProps = filterStyles(flattenArray(props.animatedProps ?? []));
+    this._prevAnimatedProps = this._animatedProps;
+    this._animatedProps = filteredAnimatedProps.animatedStyles;
+    if (filteredAnimatedProps.cssStyle) {
+      if (__DEV__ && filteredStyles.cssStyle) {
+        logger.warn('AnimatedComponent: CSS properties cannot be used in style and animatedProps at the same time. Using properties from the style object.');
+        this._cssStyle = filteredStyles.cssStyle;
+        return;
+      }
+
+      // Add all remaining props to cssStyle object
+      // (e.g. SVG components are styled via top level props, not via style object)
+      const mergedProps = {
+        ...props,
+        ...filteredAnimatedProps.cssStyle
+      };
+      delete mergedProps.style;
+      delete mergedProps.animatedProps;
+      this._cssStyle = mergedProps;
+    } else {
+      this._cssStyle = filteredStyles.cssStyle ?? {};
+    }
+  }
+  _configureLayoutAnimation(type, currentConfig, previousConfig) {
+    if (IS_WEB || currentConfig === previousConfig) {
+      return;
+    }
+    updateLayoutAnimations(type === LayoutAnimationType.ENTERING ? this.reanimatedID : this.getComponentViewTag(), type, currentConfig && maybeBuild(currentConfig, type === LayoutAnimationType.LAYOUT ? undefined /* We don't have to warn user if style has common properties with animation for LAYOUT */ : this.props?.style, this._displayName));
+  }
+
+  // This is a component lifecycle method from React, therefore we are not calling it directly.
+  // It is called before the component gets rerendered. This way we can access components' position before it changed
+  // and later on, in componentDidUpdate, calculate translation for layout transition.
+  getSnapshotBeforeUpdate() {
+    if (IS_WEB && this.props.layout && this._componentDOMRef?.getBoundingClientRect) {
+      return this._componentDOMRef.getBoundingClientRect();
+    }
+
+    // `getSnapshotBeforeUpdate` has to return value which is not `undefined`.
+    return null;
+  }
+  render() {
+    const filteredProps = this._PropsFilter.filterNonAnimatedProps(this);
+    if (IS_JEST) {
+      filteredProps.jestAnimatedStyle = this.jestAnimatedStyle;
+      filteredProps.jestAnimatedProps = this.jestAnimatedProps;
+    }
+
+    // Layout animations on web are set inside `componentDidMount` method, which is called after first render.
+    // Because of that we can encounter a situation in which component is visible for a short amount of time, and later on animation triggers.
+    // I've tested that on various browsers and devices and it did not happen to me. To be sure that it won't happen to someone else,
+    // I've decided to hide component at first render. Its visibility is reset in `componentDidMount`.
+    if (this._isFirstRender && IS_WEB && filteredProps.entering && !getReducedMotionFromConfig(filteredProps.entering)) {
+      filteredProps.style = Array.isArray(filteredProps.style) ? filteredProps.style.concat([{
+        visibility: 'hidden'
+      }]) : {
+        ...(filteredProps.style ?? {}),
+        visibility: 'hidden' // Hide component until `componentDidMount` triggers
+      };
+    }
+    const skipEntering = this.context?.current;
+    const nativeID = skipEntering ? undefined : `${this.reanimatedID}`;
+    const jestProps = IS_JEST ? {
+      jestInlineStyle: this.props.style && filterOutAnimatedStyles(this.props.style),
+      jestAnimatedStyle: this.jestAnimatedStyle,
+      jestAnimatedProps: this.jestAnimatedProps
+    } : {};
+    return super.render({
+      nativeID,
+      ...filteredProps,
+      ...jestProps
+    });
+  }
+}
+function filterOutAnimatedStyles(style) {
+  if (!style) {
+    return style;
+  }
+  if (!Array.isArray(style)) {
+    return style?.viewDescriptors ? {} : style;
+  }
+  return style.filter(styleElement => !(styleElement && 'viewDescriptors' in styleElement)).map(styleElement => {
+    if (Array.isArray(styleElement)) {
+      return filterOutAnimatedStyles(styleElement);
+    }
+    return styleElement;
+  });
+}
+//# sourceMappingURL=AnimatedComponent.js.map
\ No newline at end of file
diff --git a/lib/module/layoutReanimation/web/animationParser.js b/lib/module/layoutReanimation/web/animationParser.js
index 5cb2ed16e5ef86b4adc142e1ecf98971988ac581..9db8e4c838c210de1bcd7702c110a53b77a1c768 100644
--- a/lib/module/layoutReanimation/web/animationParser.js
+++ b/lib/module/layoutReanimation/web/animationParser.js
@@ -3,18 +3,27 @@
 import { WebEasings } from './Easing.web';
 export function convertAnimationObjectToKeyframes(animationObject) {
   let keyframe = `@keyframes ${animationObject.name} { `;
-  for (const [timestamp, style] of Object.entries(animationObject.style)) {
-    const step = timestamp === 'from' ? 0 : timestamp === 'to' ? 100 : timestamp;
+  const steps = Object.entries(animationObject.style).map(([timestamp, style]) => {
+    const step = timestamp === 'from' ? 0 : timestamp === 'to' ? 100 : Number.parseFloat(timestamp);
+    return [step, style];
+  }).sort((a, b) => a[0] - b[0]);
+  for (let i = 0; i < steps.length; i++) {
+    const [step, style] = steps[i];
     keyframe += `${step}% { `;
+
+    const easing = steps[i + 1]?.[1]?.easing;
+    if (easing) {
+      let easingName = 'linear';
+      if (easing in WebEasings) {
+        easingName = easing;
+      } else if (easing.name in WebEasings) {
+        easingName = easing.name;
+      }
+      keyframe += `animation-timing-function: cubic-bezier(${WebEasings[easingName].toString()});`;
+    }
+
     for (const [property, values] of Object.entries(style)) {
       if (property === 'easing') {
-        let easingName = 'linear';
-        if (values in WebEasings) {
-          easingName = values;
-        } else if (values.name in WebEasings) {
-          easingName = values.name;
-        }
-        keyframe += `animation-timing-function: cubic-bezier(${WebEasings[easingName].toString()});`;
         continue;
       }
       if (property === 'originX') {
diff --git a/lib/module/layoutReanimation/web/animationParser.js.orig b/lib/module/layoutReanimation/web/animationParser.js.orig
new file mode 100644
index 0000000000000000000000000000000000000000..5cb2ed16e5ef86b4adc142e1ecf98971988ac581
--- /dev/null
+++ b/lib/module/layoutReanimation/web/animationParser.js.orig
@@ -0,0 +1,46 @@
+'use strict';
+
+import { WebEasings } from './Easing.web';
+export function convertAnimationObjectToKeyframes(animationObject) {
+  let keyframe = `@keyframes ${animationObject.name} { `;
+  for (const [timestamp, style] of Object.entries(animationObject.style)) {
+    const step = timestamp === 'from' ? 0 : timestamp === 'to' ? 100 : timestamp;
+    keyframe += `${step}% { `;
+    for (const [property, values] of Object.entries(style)) {
+      if (property === 'easing') {
+        let easingName = 'linear';
+        if (values in WebEasings) {
+          easingName = values;
+        } else if (values.name in WebEasings) {
+          easingName = values.name;
+        }
+        keyframe += `animation-timing-function: cubic-bezier(${WebEasings[easingName].toString()});`;
+        continue;
+      }
+      if (property === 'originX') {
+        keyframe += `left: ${values}px; `;
+        continue;
+      }
+      if (property === 'originY') {
+        keyframe += `top: ${values}px; `;
+        continue;
+      }
+      if (property !== 'transform') {
+        keyframe += `${property}: ${values}; `;
+        continue;
+      }
+      keyframe += `transform:`;
+      values.forEach(value => {
+        for (const [transformProperty, transformPropertyValue] of Object.entries(value)) {
+          keyframe += ` ${transformProperty}(${transformPropertyValue})`;
+        }
+      });
+      keyframe += `; `; // Property end
+    }
+    keyframe += `} `; // Timestamp end
+  }
+  keyframe += `} `; // Keyframe end
+
+  return keyframe;
+}
+//# sourceMappingURL=animationParser.js.map
\ No newline at end of file
diff --git a/lib/module/layoutReanimation/web/componentUtils.js b/lib/module/layoutReanimation/web/componentUtils.js
index 8b00694a513299cfec95c08ab72e1cadd5569281..d29286d041df6dfed4b5b38aa880fbec6c0549b7 100644
--- a/lib/module/layoutReanimation/web/componentUtils.js
+++ b/lib/module/layoutReanimation/web/componentUtils.js
@@ -161,7 +161,10 @@ export function setElementAnimation(element, animationConfig, shouldSavePosition
   if (!(animationName in Animations)) {
     scheduleAnimationCleanup(animationName, duration + delay, () => {
       if (shouldSavePosition) {
-        setElementPosition(element, snapshots.get(element));
+        const snapshot = snapshots.get(element);
+        if (snapshot) {
+          setElementPosition(element, snapshot);
+        }
       }
       maybeRemoveElement();
       maybeCallCallback(false);
@@ -232,6 +235,7 @@ export function handleExitingAnimation(element, animationConfig) {
   const parent = element.offsetParent;
   const dummy = element.cloneNode();
   dummy.reanimatedDummy = true;
+  element.reanimatedDummyRef = dummy;
   element.style.animationName = '';
   dummy.style.animationName = '';
 
diff --git a/lib/module/layoutReanimation/web/componentUtils.js.orig b/lib/module/layoutReanimation/web/componentUtils.js.orig
new file mode 100644
index 0000000000000000000000000000000000000000..8b00694a513299cfec95c08ab72e1cadd5569281
--- /dev/null
+++ b/lib/module/layoutReanimation/web/componentUtils.js.orig
@@ -0,0 +1,294 @@
+'use strict';
+
+import { logger } from '../../common';
+import { LayoutAnimationType, ReduceMotion } from '../../commonTypes';
+import { EasingNameSymbol } from '../../Easing';
+import { _updatePropsJS } from '../../ReanimatedModule/js-reanimated';
+import { ReducedMotionManager } from '../../ReducedMotion';
+import { Keyframe } from '../animationBuilder';
+import { setElementPosition, snapshots } from './componentStyle';
+import { Animations, TransitionType } from './config';
+import { TransitionGenerator } from './createAnimation';
+import { scheduleAnimationCleanup } from './domUtils';
+import { getEasingByName, maybeGetBezierEasing, WebEasings } from './Easing.web';
+import { prepareCurvedTransition } from './transition/Curved.web';
+function getEasingFromConfig(config) {
+  if (!config.easingV) {
+    return getEasingByName('linear');
+  }
+  const easingName = config.easingV[EasingNameSymbol];
+  if (easingName in WebEasings) {
+    return getEasingByName(easingName);
+  }
+  const bezierEasing = maybeGetBezierEasing(config.easingV);
+  if (!bezierEasing) {
+    logger.warn(`Selected easing is not currently supported on web. Using linear easing instead.`);
+    return getEasingByName('linear');
+  }
+  return bezierEasing;
+}
+function getRandomDelay(maxDelay = 1000) {
+  return Math.floor(Math.random() * (maxDelay + 1)) / 1000;
+}
+function getDelayFromConfig(config) {
+  const shouldRandomizeDelay = config.randomizeDelay;
+  const delay = shouldRandomizeDelay ? getRandomDelay() : 0;
+  if (!config.delayV) {
+    return delay;
+  }
+  return shouldRandomizeDelay ? getRandomDelay(config.delayV) : config.delayV / 1000;
+}
+export function getReducedMotionFromConfig(config) {
+  if (!config.reduceMotionV) {
+    return ReducedMotionManager.jsValue;
+  }
+  switch (config.reduceMotionV) {
+    case ReduceMotion.Never:
+      return false;
+    case ReduceMotion.Always:
+      return true;
+    default:
+      return ReducedMotionManager.jsValue;
+  }
+}
+function getDurationFromConfig(config, animationName) {
+  // Duration in keyframe has to be in seconds. However, when using `.duration()` modifier we pass it in miliseconds.
+  // If `duration` was specified in config, we have to divide it by `1000`, otherwise we return value that is already in seconds.
+
+  const defaultDuration = animationName in Animations ? Animations[animationName].duration : 0.3;
+  return config.durationV !== undefined ? config.durationV / 1000 : defaultDuration;
+}
+function getCallbackFromConfig(config) {
+  return config.callbackV !== undefined ? config.callbackV : null;
+}
+function getReversedFromConfig(config) {
+  return !!config.reversed;
+}
+export function getProcessedConfig(animationName, animationType, config) {
+  return {
+    animationName,
+    animationType,
+    duration: getDurationFromConfig(config, animationName),
+    delay: getDelayFromConfig(config),
+    easing: getEasingFromConfig(config),
+    callback: getCallbackFromConfig(config),
+    reversed: getReversedFromConfig(config)
+  };
+}
+export function maybeModifyStyleForKeyframe(element, config) {
+  if (!(config instanceof Keyframe)) {
+    return;
+  }
+
+  // We need to set `animationFillMode` to `forwards`, otherwise component will go back to its position.
+  // This will result in wrong snapshot
+  element.style.animationFillMode = 'forwards';
+  for (const timestampRules of Object.values(config.definitions)) {
+    if ('originX' in timestampRules || 'originY' in timestampRules) {
+      element.style.position = 'absolute';
+      return;
+    }
+  }
+}
+export function saveSnapshot(element) {
+  const rect = element.getBoundingClientRect();
+  const snapshot = {
+    top: rect.top,
+    left: rect.left,
+    width: rect.width,
+    height: rect.height,
+    scrollOffsets: getElementScrollValue(element)
+  };
+  snapshots.set(element, snapshot);
+}
+export function setElementAnimation(element, animationConfig, shouldSavePosition = false, parent = null) {
+  const {
+    animationName,
+    duration,
+    delay,
+    easing
+  } = animationConfig;
+  const configureAnimation = () => {
+    element.style.animationName = animationName;
+    element.style.animationFillMode = 'backwards';
+    element.style.animationDuration = `${duration}s`;
+    element.style.animationDelay = `${delay}s`;
+    element.style.animationTimingFunction = easing;
+  };
+  if (animationConfig.animationType === LayoutAnimationType.ENTERING) {
+    // On chrome sometimes entering animations flicker. This is most likely caused by animation being interrupted
+    // by already started tasks. To avoid flickering, we use `requestAnimationFrame`, which will run callback right before repaint.
+    requestAnimationFrame(configureAnimation);
+  } else {
+    configureAnimation();
+  }
+  const maybeRemoveElement = () => {
+    if (element.reanimatedDummy && parent?.contains(element)) {
+      element.removedAfterAnimation = true;
+      parent.removeChild(element);
+    }
+  };
+  let wasCallbackCalled = false;
+  const maybeCallCallback = finished => {
+    if (!wasCallbackCalled && animationConfig.callback) {
+      animationConfig.callback(finished);
+      wasCallbackCalled = true;
+    }
+  };
+  element.onanimationend = () => {
+    if (shouldSavePosition) {
+      saveSnapshot(element);
+    }
+    maybeRemoveElement();
+    maybeCallCallback(true);
+    element.removeEventListener('animationcancel', animationCancelHandler);
+  };
+  const animationCancelHandler = () => {
+    maybeRemoveElement();
+    maybeCallCallback(false);
+    element.removeEventListener('animationcancel', animationCancelHandler);
+  };
+
+  // Here we have to use `addEventListener` since element.onanimationcancel doesn't work on chrome
+  element.onanimationstart = () => {
+    if (animationConfig.animationType === LayoutAnimationType.ENTERING) {
+      _updatePropsJS({
+        visibility: 'initial'
+      }, element);
+    }
+    element.addEventListener('animationcancel', animationCancelHandler);
+  };
+  if (!(animationName in Animations)) {
+    scheduleAnimationCleanup(animationName, duration + delay, () => {
+      if (shouldSavePosition) {
+        setElementPosition(element, snapshots.get(element));
+      }
+      maybeRemoveElement();
+      maybeCallCallback(false);
+    });
+  }
+}
+export function handleLayoutTransition(element, animationConfig, transitionData) {
+  const {
+    animationName
+  } = animationConfig;
+  let animationType;
+  switch (animationName) {
+    case 'LinearTransition':
+      animationType = TransitionType.LINEAR;
+      break;
+    case 'SequencedTransition':
+      animationType = TransitionType.SEQUENCED;
+      break;
+    case 'FadingTransition':
+      animationType = TransitionType.FADING;
+      break;
+    case 'JumpingTransition':
+      animationType = TransitionType.JUMPING;
+      break;
+    case 'CurvedTransition':
+      animationType = TransitionType.CURVED;
+      break;
+    case 'EntryExitTransition':
+      animationType = TransitionType.ENTRY_EXIT;
+      break;
+    default:
+      animationType = TransitionType.LINEAR;
+      break;
+  }
+  const {
+    transitionKeyframeName,
+    dummyTransitionKeyframeName
+  } = TransitionGenerator(animationType, transitionData);
+  animationConfig.animationName = transitionKeyframeName;
+  if (animationType === TransitionType.CURVED) {
+    const {
+      dummy,
+      dummyAnimationConfig
+    } = prepareCurvedTransition(element, animationConfig, transitionData, dummyTransitionKeyframeName // In `CurvedTransition` it cannot be undefined
+    );
+    setElementAnimation(dummy, dummyAnimationConfig);
+  }
+  setElementAnimation(element, animationConfig);
+}
+function getElementScrollValue(element) {
+  let current = element;
+  const scrollOffsets = {
+    scrollTopOffset: 0,
+    scrollLeftOffset: 0
+  };
+  while (current) {
+    if (current.scrollTop !== 0 && scrollOffsets.scrollTopOffset === 0) {
+      scrollOffsets.scrollTopOffset = current.scrollTop;
+    }
+    if (current.scrollLeft !== 0 && scrollOffsets.scrollLeftOffset === 0) {
+      scrollOffsets.scrollLeftOffset = current.scrollLeft;
+    }
+    current = current.parentElement;
+  }
+  return scrollOffsets;
+}
+export function handleExitingAnimation(element, animationConfig) {
+  const parent = element.offsetParent;
+  const dummy = element.cloneNode();
+  dummy.reanimatedDummy = true;
+  element.style.animationName = '';
+  dummy.style.animationName = '';
+
+  // Moving elements in DOM resets their scroll positions
+  // so we memorize them here and restore after
+  const scrollPositions = new Map();
+  const saveScrollPosition = node => {
+    scrollPositions.set(node, {
+      top: node.scrollTop,
+      left: node.scrollLeft
+    });
+    for (const child of Array.from(node.children)) {
+      saveScrollPosition(child);
+    }
+  };
+  saveScrollPosition(element);
+
+  // After cloning the element, we want to move all children from original element to its clone. This is because original element
+  // will be unmounted, therefore when this code executes in child component, parent will be either empty or removed soon.
+  // Using element.cloneNode(true) doesn't solve the problem, because it creates copy of children and we won't be able to set their animations
+  //
+  // This loop works because appendChild() moves element into its new parent instead of copying it
+  while (element.firstChild) {
+    dummy.appendChild(element.firstChild);
+  }
+  parent?.appendChild(dummy);
+  const restoreScrollPosition = node => {
+    const scrollPosition = scrollPositions.get(node === dummy ? element : node);
+    if (scrollPosition) {
+      node.scrollTop = scrollPosition.top;
+      node.scrollLeft = scrollPosition.left;
+    }
+    for (const child of Array.from(node.children)) {
+      restoreScrollPosition(child);
+    }
+  };
+  restoreScrollPosition(dummy);
+  const snapshot = snapshots.get(element);
+  const scrollOffsets = getElementScrollValue(element);
+
+  // Scroll does not trigger snapshotting, therefore if we start exiting animation after
+  // scrolling through parent component, dummy will end up in wrong place. In order to fix that
+  // we keep last known scroll position in snapshot and then adjust dummy position based on
+  // last known scroll offset and current scroll offset
+
+  const currentScrollTopOffset = scrollOffsets.scrollTopOffset;
+  const lastScrollTopOffset = snapshot.scrollOffsets.scrollTopOffset;
+  if (currentScrollTopOffset !== lastScrollTopOffset) {
+    snapshot.top += lastScrollTopOffset - currentScrollTopOffset;
+  }
+  const currentScrollLeftOffset = scrollOffsets.scrollLeftOffset;
+  const lastScrollLeftOffset = snapshot.scrollOffsets.scrollLeftOffset;
+  if (currentScrollLeftOffset !== lastScrollLeftOffset) {
+    snapshot.left += lastScrollLeftOffset - currentScrollLeftOffset;
+  }
+  snapshots.set(dummy, snapshot);
+  setElementPosition(dummy, snapshot);
+  setElementAnimation(dummy, animationConfig, false, parent);
+}
+//# sourceMappingURL=componentUtils.js.map
\ No newline at end of file
