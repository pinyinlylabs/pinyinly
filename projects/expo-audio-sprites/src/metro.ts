import { cachedManifestLoader, findSpriteSegment } from "#manifestRead.ts";
import * as fs from "@pinyinly/lib/fs";
import type { MetroConfig } from "metro-config";
import type { Resolution } from "metro-resolver";
import crypto from "node:crypto";
import path from "node:path";

interface WithAudioSpritesOptions {
  manifestPath: string;
  cachePath: string;
}

export function withAudioSprites<T extends MetroConfig>(
  config: T,
  options: WithAudioSpritesOptions,
): T {
  const proxyDirPath = path.resolve(options.cachePath);

  const loadCachedManifest = cachedManifestLoader(options.manifestPath);

  return {
    ...config,

    resolver: {
      ...config.resolver,
      resolveRequest(context, moduleName, platform): Resolution {
        const parentResolver =
          config.resolver?.resolveRequest ?? context.resolveRequest;

        const modulePath = path.resolve(
          path.dirname(context.originModulePath),
          moduleName,
        );

        //
        // Case 1 -- intercept require(â€¦) from our proxy files.
        //
        if (path.dirname(context.originModulePath) === proxyDirPath) {
          //
          // Case 1.1 -- deleted sprites
          //
          // In this case all proxy files that reference the sprite should be
          // deleted so that they can be regenerated with the correct sprite.

          if (!fs.existsSync(modulePath)) {
            // The target sprite has been deleted. When a sprite is deleted it
            // picks just one "origin" module to re-perform the resolution. So
            // we need to find all the other "origin" modules (proxy files) and
            // delete them so that they are re-resolved too. They'll be
            // generated on-the-fly when they're resolved.
            for (const path of fs.grepSync(`${proxyDirPath}/*`, moduleName)) {
              // Unlinking (or renaming) the module is necessary to retrigger
              // metro resolution.
              //
              // However there's a race condition where Metro might try to hash
              // the file, so this can something cause errors. But refreshing
              // the page fixes it.
              fs.unlinkSync(path);
            }

            // Return an empty module for the deleted sprite to avoid crashing
            // the page, it's a better DX.
            return { type: `empty` };
          }

          // Otherwise allow the normal resolution to proceed.
          return parentResolver(context, moduleName, platform);
        }

        //
        // Case 2 -- Requiring an audio file e.g. `require("./shang.m4a")`
        //
        if (moduleName.endsWith(`.m4a`)) {
          // Check the manifest to see if it's part of a sprite, and if it is,
          // we need to load the sprite instead. To do this we generate a proxy
          // module that includes the timing (start/duration) information as
          // well as requiring the sprite asset.

          const manifest = loadCachedManifest();

          if (manifest != null) {
            const segment = findSpriteSegment(
              manifest,
              options.manifestPath,
              modulePath,
            );

            if (segment) {
              const proxyFilePath = writeProxyFileSync(
                segment,
                modulePath,
                proxyDirPath,
              );

              return { type: `sourceFile`, filePath: proxyFilePath };
            }
          }
        }

        return parentResolver(context, moduleName, platform);
      },
    },
  };
}

function writeProxyFileSync(
  segment: NonNullable<ReturnType<typeof findSpriteSegment>>,
  modulePath: string,
  proxyDirPath: string,
): string {
  const key = crypto
    .createHash(`sha1`)
    .update(modulePath)
    .digest(`hex`)
    .slice(0, 16);

  // Instead of an opaque proxy module, include part of the original filename
  // for easier debugging.
  const debugPrefix = path.basename(modulePath, path.extname(modulePath));
  const outFilePath = path.join(proxyDirPath, `${debugPrefix}-${key}.cjs`);

  const code = `\
// auto-generated by pinyinly
module.exports = {
  start: ${JSON.stringify(segment.start)},
  duration: ${JSON.stringify(segment.duration)},
  asset: require(${JSON.stringify(path.relative(proxyDirPath, segment.spritePath))})
};`;

  // Always create the directory in case it was deleted by the developer.
  fs.mkdirSync(proxyDirPath, { recursive: true });
  fs.writeFileSync(outFilePath, code);

  return outFilePath;
}
